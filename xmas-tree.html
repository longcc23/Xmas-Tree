<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>3D Á≤íÂ≠êÂú£ËØûÊ†ë - ÈáèÂ≠êÁªàÊûÅÁâà</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Courier New', Courier, monospace;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #ui-layer {
            position: absolute;
            top: 10px;
            right: 10px; 
            left: auto;
            z-index: 10;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
            text-align: right;
        }
        @media (max-width: 768px) {
            #ui-layer {
                top: 5px;
                right: 5px;
            }
        }
        h1 {
            font-size: clamp(1rem, 4vw, 1.6rem);
            margin: 0 0 5px 0;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            font-weight: bold;
            letter-spacing: 1px;
        }
        p {
            font-size: clamp(0.7rem, 2.5vw, 0.9rem);
            margin: 3px 0;
            color: #ccc;
        }
        .instruction {
            font-size: clamp(0.65rem, 2vw, 0.8rem);
            color: #aaa;
            margin-top: 8px;
            background: rgba(0,0,0,0.5);
            padding: 6px 10px;
            border-radius: 6px;
            display: inline-block;
            border-right: 3px solid #ffcc00; 
            border-left: none;
            max-width: 90vw;
            box-sizing: border-box;
        }
        #title-text {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Great Vibes', cursive;
            font-size: clamp(3rem, 8vw, 5rem);
            color: #fff;
            text-shadow: 0 0 10px #ffcc00, 0 0 20px #ffcc00, 0 0 30px #ff0000;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            white-space: nowrap;
            letter-spacing: 2px;
        }
        @media (max-width: 768px) {
            #title-text {
                bottom: 15%;
            }
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            z-index: 20;
            pointer-events: none;
            transition: opacity 0.5s;
            text-align: center;
            background: rgba(0,0,0,0.6);
            padding: 20px 30px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #ff3333;
            margin-right: 8px;
            vertical-align: middle;
        }
        .status-dot.active {
            background-color: #33ff33;
            box-shadow: 0 0 8px #33ff33;
        }
        #webcam {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            width: 1px;
            height: 1px;
        }
        #error-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(50, 0, 0, 0.8);
            color: #ffaaaa;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.8rem;
            z-index: 30;
            display: none;
            border: 1px solid #ff5555;
            pointer-events: none;
        }
        /* dat.GUI Âú®Â∑¶‰∏ãËßí‰∏îÂ±ÇÁ∫ßÊ≠£Á°Æ */
        .dg.ac {
            z-index: 20 !important;
            position: fixed !important;
            top: auto !important;
            bottom: 20px !important;
            left: 20px !important;
            right: auto !important;
        }
        @media (max-width: 768px) {
            .dg.ac {
                transform: scale(0.75);
                transform-origin: bottom left;
                bottom: 10px !important;
                left: 10px !important;
            }
        }
        #tap-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: #ffcc00;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 0.75rem;
            z-index: 15;
            pointer-events: none;
            border: 1px solid rgba(255,204,0,0.3);
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        @media (max-width: 768px) {
            #tap-hint {
                bottom: 80px;
                right: 10px;
                font-size: 0.7rem;
                padding: 8px 12px;
            }
        }
    </style>
</head>
<body>

    <div id="loading">
        Ê≠£Âú®Âä†ËΩΩÈ≠îÊ≥ï...<br>
        <span style="font-size:0.8rem; color:#aaa;">(Ê®°Âûã‰∏éÁùÄËâ≤Âô®ÁºñËØë‰∏≠)</span>
    </div>

    <div id="error-toast"></div>

    <div id="ui-layer">
        <h1>ÈáèÂ≠êÂú£ËØûÊ†ë - Merry Xmas!</h1>
        <p><span id="control-mode">Ê£ÄÊµã‰∫§‰∫íÊ®°Âºè...</span> <span id="cam-status" class="status-dot"></span></p>
        <p>ÂΩìÂâçÈ£éÊ†º: <span id="style-name" style="color:#ffcc00; font-weight:bold;">ÊµÅÈáëÂÖâËæâ</span></p>
        <div class="instruction" id="instruction-text">
            ‚ÜîÔ∏è È£üÊåáÂÅèÁßªÔºöÈôÄËû∫ÊóãËΩ¨<br>
            üëå ÊãáÊåáÈ£üÊåáÔºöÊçèÂêàÁº©Êîæ<br>
            üé® Â∑¶‰∏ãËßíÈù¢ÊùøÂàáÊç¢È£éÊ†º
        </div>
    </div>

    <div id="tap-hint">üëÜ ÁÇπÂáªÂ±èÂπïÂàáÊç¢È£éÊ†º</div>
    
    <div id="title-text">Merry Christmas</div>

    <div id="canvas-container"></div>
    <!-- ÈùôÈü≥ËßÜÈ¢ë‰ª•ÂÖÅËÆ∏Ëá™Âä®Êí≠Êîæ -->
    <video id="webcam" autoplay playsinline muted></video>

    <!-- Import Libraries via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <!-- Main Logic as Module -->
    <script type="module">
        import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

        /**
         * CONFIGURATION
         */
        // Ê£ÄÊµãÁßªÂä®ËÆæÂ§á
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
        
        const config = {
            particleCount: isMobile ? 2000 : 4000, 
            treeHeight: 35,
            baseRadius: 13,
            style: 0, 
            bloomStrength: isMobile ? 0.4 : 0.7, 
            bloomThreshold: 0.15,
            bloomRadius: isMobile ? 0.4 : 0.6,
            interactionSensitivity: 2.5, 
            defaultCamZ: isMobile ? 45 : 40,
            minCamZ: 20,
            maxCamZ: 70,
            baseRotationSpeed: 0.2,  
            maxRotationSpeed: 6.0    
        };

        const state = {
            mouse: new THREE.Vector2(0, 0),
            hasHand: false,
            styleMorph: 0.0,
            time: 0,
            accumulatedRotation: 0 
        };

        const container = document.getElementById('canvas-container');
        const loadingEl = document.getElementById('loading');
        const errorToast = document.getElementById('error-toast');
        const styleNameEl = document.getElementById('style-name');
        const video = document.getElementById('webcam');
        const camStatus = document.getElementById('cam-status');
        const controlModeEl = document.getElementById('control-mode');
        const instructionEl = document.getElementById('instruction-text');

        function showToast(msg) {
            errorToast.innerHTML = msg;
            errorToast.style.display = 'block';
            setTimeout(() => { errorToast.style.opacity = 0; }, 5000);
        }

        controlModeEl.innerText = isMobile ? "Ëß¶ÊéßÊ®°Âºè" : "Èº†Ê†áÊéßÂà∂Ê®°Âºè";

        /**
         * THREE.JS SETUP
         */
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, config.defaultCamZ);
        camera.lookAt(0, 10, 0);

        const renderer = new THREE.WebGLRenderer({ 
            antialias: !isMobile, 
            powerPreference: "high-performance",
            alpha: false
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        /**
         * POST PROCESSING
         */
        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            config.bloomStrength,
            config.bloomRadius,
            config.bloomThreshold
        );
        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        /**
         * SHADER 
         */
        const vertexShader = `
            uniform float uTime;
            uniform float uRotation; 
            uniform float uMorph; 
            uniform float uIntro; // 0.0 = Galaxy, 1.0 = Tree
            uniform vec2 uMouse;
            uniform float uPixelRatio;

            attribute vec3 positionA; 
            attribute vec3 positionB; 
            attribute vec3 positionC; 
            attribute vec3 positionIntro; 
            
            attribute vec3 colorA;
            attribute vec3 colorB;
            attribute vec3 colorC;
            attribute vec3 colorIntro; 
            
            attribute float size;
            attribute float random;

            varying vec3 vColor;

            mat2 rotate2d(float _angle){
                return mat2(cos(_angle),-sin(_angle), sin(_angle),cos(_angle));
            }

            void main() {
                // 1. Morphing (Style Transition)
                vec3 targetPos;
                vec3 targetCol;
                
                if (uMorph < 1.0) {
                    float t = smoothstep(0.0, 1.0, uMorph);
                    targetPos = mix(positionA, positionB, t);
                    targetCol = mix(colorA, colorB, t);
                } else {
                    float t = smoothstep(1.0, 2.0, uMorph);
                    targetPos = mix(positionB, positionC, t);
                    targetCol = mix(colorB, colorC, t);
                }

                // 2. Intro Transition (Galaxy -> Tree)
                vec3 pos;
                vec3 col;
                
                float introT = smoothstep(0.0, 1.0, uIntro);
                
                if (uIntro < 1.0) {
                    vec3 mixedPos = mix(positionIntro, targetPos, introT);
                    float twist = (1.0 - introT) * 10.0 * (1.0 + random);
                    float dist = length(mixedPos.xz);
                    float angle = twist * (1.0 - dist/50.0);
                    mixedPos.xz *= rotate2d(angle);
                    pos = mixedPos;
                    col = mix(colorIntro, targetCol, introT);
                } else {
                    pos = targetPos;
                    col = targetCol;
                }

                // 3. Global Spin (Accumulated)
                pos.xz *= rotate2d(uRotation);

                // 4. AUTO SWAY (Subtle physics)
                // Only sway when fully formed
                float heightFactor = clamp((pos.y + 15.0) / 40.0, 0.0, 1.0);
                float interactionStrength = 0.5 * uIntro; // No sway during intro
                float windSway = sin(uTime * 1.5) * pow(heightFactor, 2.0); 
                
                pos.x += windSway * interactionStrength;
                pos.z += cos(uTime * 1.2) * pow(heightFactor, 2.0) * interactionStrength * 0.5;
                
                // 5. Breathing
                float breathe = sin(uTime * 2.0 + random * 10.0) * 0.5 + 0.5;
                
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                // 6. Size
                float calculatedSize = size * (1.0 + breathe * 0.5) * uPixelRatio * (20.0 / -mvPosition.z);
                gl_PointSize = clamp(calculatedSize, 2.0, 35.0);

                vColor = col;
            }
        `;

        const fragmentShader = `
            uniform sampler2D pointTexture;
            varying vec3 vColor;

            void main() {
                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);
                if (dist > 0.5) discard;
                float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
                gl_FragColor = vec4(vColor, alpha);
            }
        `;

        const generateParticles = () => {
            const count = config.particleCount;
            const geom = new THREE.BufferGeometry();
            const posA=[], posB=[], posC=[], posIntro=[], colA=[], colB=[], colC=[], colIntro=[], sizes=[], randoms=[];
            const colorHelper = new THREE.Color();

            for (let i = 0; i < count; i++) {
                const r = Math.random();
                const r2 = Math.random();
                const r3 = Math.random();

                // --- Intro: Sparse Galaxy ---
                // Random sphere/disc distribution
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const radiusIntro = 30 + Math.random() * 40; // Wide spread
                posIntro.push(
                    radiusIntro * Math.sin(phi) * Math.cos(theta),
                    radiusIntro * Math.sin(phi) * Math.sin(theta),
                    radiusIntro * Math.cos(phi)
                );
                // Silver-Blue faint stars
                colorHelper.setHSL(0.6, 0.8, 0.8); // Blueish Silver
                colIntro.push(colorHelper.r, colorHelper.g, colorHelper.b);

                // --- Style A: Cosmic Continuous Spiral (Refined) ---
                const yA = r * config.treeHeight;
                const progressA = yA / config.treeHeight;
                const radiusA = config.baseRadius * (1.0 - progressA);
                
                // Use a continuous spiral based on index to fill gaps
                // More loops for denser look
                const loops = 12.0; 
                // Combine height progress with index for continuous thread
                const angleA = (progressA * Math.PI * 2 * loops) + (i * 0.1); 
                
                // Add volumetric noise to make it less like a single wire
                const noiseRadius = (r2 - 0.5) * 4.0 * (1.0 - progressA); // More spread at bottom
                const noiseAngle = r3 * Math.PI * 2;
                
                posA.push(
                    Math.cos(angleA) * radiusA + Math.cos(noiseAngle) * noiseRadius, 
                    yA - config.treeHeight/2 + 5, 
                    Math.sin(angleA) * radiusA + Math.sin(noiseAngle) * noiseRadius
                );
                
                // Neon Tech / Cosmic Colors
                if (Math.random() > 0.7) colorHelper.setHex(0xFFD700); // Gold
                else if (Math.random() > 0.5) colorHelper.setHex(0x00FFFF); // Cyan
                else colorHelper.setHex(0xFF00FF); // Purple
                
                colA.push(colorHelper.r, colorHelper.g, colorHelper.b);


                // --- Style B: Frozen (Continuous Ice Crystal Cone) ---
                // Replaced layered ring logic with continuous distribution
                const yB = r * config.treeHeight; // Continuous height
                const radiusB = config.baseRadius * (1.0 - yB/config.treeHeight) * 1.2;
                const angleB = r2 * Math.PI * 2;
                // Add thickness to the surface to look like an ice crystal shell
                const thicknessB = (r3 - 0.5) * 1.5; 
                
                posB.push(
                    Math.cos(angleB)*(radiusB + thicknessB), 
                    yB - config.treeHeight/2 + 5, 
                    Math.sin(angleB)*(radiusB + thicknessB)
                );
                // Icy Colors
                if (Math.random() > 0.8) colorHelper.setHex(0xFFFFFF);
                else if (Math.random() > 0.5) colorHelper.setHex(0x00FFFF);
                else colorHelper.setHex(0x002288);
                colB.push(colorHelper.r, colorHelper.g, colorHelper.b);


                // --- Style C: Forest (Volumetric Fill) ---
                let yC = Math.random() * config.treeHeight;
                // Sqrt for uniform distribution inside the circle (Volume)
                let radC = Math.sqrt(Math.random()) * (config.baseRadius * (1.0 - yC/config.treeHeight)); 
                let angC = Math.random() * Math.PI * 2;
                
                posC.push(Math.cos(angC)*radC, yC - config.treeHeight/2 + 5, Math.sin(angC)*radC);
                // Forest Colors + More Ornaments
                if (Math.random() > 0.80) { // More lights
                    const bulb = Math.random();
                    if(bulb < 0.25) colorHelper.setHex(0xFF0000); // Red
                    else if(bulb < 0.5) colorHelper.setHex(0xFFD700); // Gold
                    else if(bulb < 0.75) colorHelper.setHex(0x9400D3); // Purple
                    else colorHelper.setHex(0x0000FF); // Blue
                } else {
                    // Deep Green
                    colorHelper.setHSL(0.35 + Math.random()*0.1, 0.8, 0.1 + Math.random()*0.2);
                }
                colC.push(colorHelper.r, colorHelper.g, colorHelper.b);


                // Shared
                sizes.push(Math.random() * 2.0 + 1.0);
                randoms.push(Math.random());
            }

            geom.setAttribute('position', new THREE.Float32BufferAttribute(posIntro, 3)); // Start at Intro
            geom.setAttribute('positionA', new THREE.Float32BufferAttribute(posA, 3));
            geom.setAttribute('positionB', new THREE.Float32BufferAttribute(posB, 3));
            geom.setAttribute('positionC', new THREE.Float32BufferAttribute(posC, 3));
            geom.setAttribute('positionIntro', new THREE.Float32BufferAttribute(posIntro, 3));
            
            geom.setAttribute('colorA', new THREE.Float32BufferAttribute(colA, 3));
            geom.setAttribute('colorB', new THREE.Float32BufferAttribute(colB, 3));
            geom.setAttribute('colorC', new THREE.Float32BufferAttribute(colC, 3));
            geom.setAttribute('colorIntro', new THREE.Float32BufferAttribute(colIntro, 3));
            
            geom.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geom.setAttribute('random', new THREE.Float32BufferAttribute(randoms, 1));
            return geom;
        };

        const particleMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uRotation: { value: 0 }, 
                uMorph: { value: 0 },
                uIntro: { value: 0 },
                uMouse: { value: new THREE.Vector2(0, 0) },
                uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) }
            },
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(generateParticles(), particleMaterial);
        scene.add(particles);

        // Star (The Golden Core)
        const starGeo = new THREE.OctahedronGeometry(0.5, 0); // Start small
        const starMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 }); // Gold
        const star = new THREE.Mesh(starGeo, starMat);
        star.position.set(0, 0, 0); // Start at center
        scene.add(star);
        
        const starLight = new THREE.PointLight(0xFFD700, 2, 50); // Warm Gold Light
        starLight.position.copy(star.position);
        scene.add(starLight);

        const titleText = document.getElementById('title-text');

        // INTRO SEQUENCE
        const introTimeline = gsap.timeline({ delay: 0.5 });
        
        // 1. Core Light Emerges
        introTimeline.fromTo(star.scale, { x:0, y:0, z:0 }, { x:2, y:2, z:2, duration: 2, ease: "elastic.out(1, 0.3)" });
        introTimeline.to(starLight, { intensity: 3, distance: 60, duration: 2 }, "<");

        // 2. Galaxy Condenses to Tree
        introTimeline.to(particleMaterial.uniforms.uIntro, {
            value: 1,
            duration: 6,
            ease: "power2.inOut"
        }, "-=1.0");

        // 3. Star moves to top
        introTimeline.to(star.position, {
            y: config.treeHeight/2 + 5,
            duration: 5,
            ease: "power2.inOut"
        }, "-=6");
        
        // 4. Text Fades In
        introTimeline.to(titleText, {
            opacity: 1,
            duration: 3,
            ease: "power2.out"
        }, "-=2");
        
        // 5. Star becomes final style (White/Bright)
        introTimeline.to(starMat.color, { r:1, g:1, b:1, duration: 2 }, "-=2");
        introTimeline.to(starLight.color, { r:1, g:1, b:1, duration: 2 }, "-=2");


        /**
         * MEDIAPIPE LOGIC
         */
        let handLandmarker = undefined;
        let lastVideoTime = -1;
        let visionRunning = false;

        async function initVision() {
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });
                startWebcam();
            } catch (e) {
                console.warn("AI Init Failed:", e);
                loadingEl.style.opacity = 0;
                showToast("AIÊ®°ÂûãÂä†ËΩΩÂ§±Ë¥•ÔºåÂ∑≤ÂàáÊç¢Ëá≥Èº†Ê†áÊ®°Âºè");
            }
        }

        function startWebcam() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                fallbackToMouse("ÊµèËßàÂô®‰∏çÊîØÊåÅÊëÑÂÉèÂ§¥ API");
                return;
            }
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    visionRunning = true;
                    loadingEl.style.opacity = 0;
                    camStatus.classList.add('active'); 
                    controlModeEl.innerText = "ÊâãÂäøËØÜÂà´‰∏≠";
                    instructionEl.innerHTML = "üëÜ È£üÊåáÂÅèÁßªÔºöÈôÄËû∫ÊóãËΩ¨ | üëå ÊçèÂêàÔºöÁº©Êîæ";
                    predictWebcam();
                });
            }).catch((err) => {
                fallbackToMouse("ÊëÑÂÉèÂ§¥ÊùÉÈôêË¢´ÊãíÁªùÊàñÈúÄË¶ÅHTTPS");
            });
        }

        function fallbackToMouse(reason) {
            loadingEl.style.opacity = 0;
            camStatus.style.backgroundColor = "#ffaa00"; 
            controlModeEl.innerText = "Èº†Ê†áÊéßÂà∂Ê®°Âºè";
            instructionEl.innerHTML = isMobile ? "üëÜ ÊªëÂä®ÊóãËΩ¨ | ü§è ÂèåÊåáÁº©Êîæ | üëá ÁÇπÂáªÂàáÊç¢È£éÊ†º" : "Ê£ÄÊµãÂà∞ÁéØÂ¢ÉÈôêÂà∂: " + reason;
            showToast("‚ö†Ô∏è " + reason + " -> Â∑≤ÂêØÁî®Èº†Ê†áÊéßÂà∂");
        }

        async function predictWebcam() {
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                if (handLandmarker) {
                    try {
                        const result = handLandmarker.detectForVideo(video, performance.now());
                        if (result.landmarks && result.landmarks.length > 0) {
                            state.hasHand = true;
                            
                            // 1. Velocity Control (Index Finger Tip: 8)
                            const tip = result.landmarks[0][8]; 
                            gsap.to(state.mouse, {
                                x: (1.0 - tip.x) * 2 - 1, 
                                y: 0, 
                                duration: 0.2, 
                                overwrite: "auto"
                            });

                            // 2. Zoom (Pinch: Thumb 4 - Index 8)
                            const thumb = result.landmarks[0][4];
                            const index = result.landmarks[0][8];
                            const dist = Math.hypot(thumb.x - index.x, thumb.y - index.y);

                            const minPinch = 0.03;
                            const maxPinch = 0.25;
                            let normDist = (dist - minPinch) / (maxPinch - minPinch);
                            normDist = Math.max(0, Math.min(1, normDist));

                            const targetZ = config.maxCamZ - (normDist * (config.maxCamZ - config.minCamZ));

                            gsap.to(camera.position, {
                                z: targetZ,
                                duration: 0.8,
                                ease: "power2.out"
                            });

                        } else {
                            if(state.hasHand) {
                                state.hasHand = false;
                                gsap.to(state.mouse, { x: 0, y: 0, duration: 1.0 });
                                gsap.to(camera.position, { z: config.defaultCamZ, duration: 1.5 });
                            }
                        }
                    } catch(e) {}
                }
            }
            if(visionRunning) requestAnimationFrame(predictWebcam);
        }

        initVision();

        window.addEventListener('mousemove', (e) => {
            if (!state.hasHand) {
                const x = (e.clientX / window.innerWidth) * 2 - 1;
                gsap.to(state.mouse, { x: x, y: 0, duration: 0.2 });
            }
        });

        window.addEventListener('wheel', (e) => {
            if (!state.hasHand) {
                const delta = e.deltaY * 0.05;
                camera.position.z = Math.max(config.minCamZ, Math.min(config.maxCamZ, camera.position.z + delta));
            }
        });

        // Ëß¶Êë∏ÊéßÂà∂
        let touchStartX = 0;
        let touchStartZ = 0;
        let lastTouchDistance = 0;
        let isTouching = false;

        window.addEventListener('touchstart', (e) => {
            isTouching = true;
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
                touchStartZ = camera.position.z;
            }
            e.preventDefault();
        }, { passive: false });

        window.addEventListener('touchmove', (e) => {
            if (!state.hasHand && isTouching) {
                if (e.touches.length === 1) {
                    // ÂçïÊåáÊªëÂä®ÊéßÂà∂ÊóãËΩ¨
                    const touchX = e.touches[0].clientX;
                    const deltaX = (touchX - touchStartX) / window.innerWidth;
                    const x = deltaX * 4;
                    gsap.to(state.mouse, { x: x, y: 0, duration: 0.1 });
                } else if (e.touches.length === 2) {
                    // ÂèåÊåáÁº©Êîæ
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const scale = distance / lastTouchDistance;
                    const newZ = touchStartZ / scale;
                    camera.position.z = Math.max(config.minCamZ, Math.min(config.maxCamZ, newZ));
                }
            }
            e.preventDefault();
        }, { passive: false });

        window.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) {
                isTouching = false;
                gsap.to(state.mouse, { x: 0, y: 0, duration: 1.0 });
            }
            e.preventDefault();
        }, { passive: false });

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getElapsedTime();
            const deltaTime = clock.getDelta(); 
            
            // Physics Rotation
            let inputX = state.mouse.x;
            if (Math.abs(inputX) < 0.1) inputX = 0;
            let targetSpeed = config.baseRotationSpeed + (inputX * config.maxRotationSpeed);
            state.accumulatedRotation += targetSpeed * 0.02;

            particleMaterial.uniforms.uTime.value = dt;
            particleMaterial.uniforms.uRotation.value = state.accumulatedRotation;
            particleMaterial.uniforms.uMouse.value.copy(state.mouse);

            // Update Star Light position
            starLight.position.copy(star.position);
            star.rotation.y = dt;
            
            if(!state.hasHand && Math.abs(state.mouse.x) < 0.1) {
                 camera.position.x = Math.sin(dt * 0.1) * 5;
            }
            camera.lookAt(0, 10, 0);

            composer.render();
        }
        animate();

        // GUI
        const gui = new dat.GUI();
        
        // ÁßªÂä®Á´ØÈªòËÆ§ÂÖ≥Èó≠ GUI
        if (isMobile) {
            gui.close();
        }

        const styleMap = { 'ÊµÅÈáëÂÖâËæâ': 0, 'ÂÜ∞Èõ™Ê¢¶Â¢É': 1, 'È≠îÊ≥ïÊ£ÆÊûó': 2 };
        const styleNames = ['ÊµÅÈáëÂÖâËæâ', 'ÂÜ∞Èõ™Ê¢¶Â¢É', 'È≠îÊ≥ïÊ£ÆÊûó'];
        const guiCtrl = { style: 'ÊµÅÈáëÂÖâËæâ' };
        let currentStyleIndex = 0;
        
        gui.add(guiCtrl, 'style', Object.keys(styleMap)).onChange((val) => {
            styleNameEl.innerText = val;
            let target = styleMap[val];
            // Update color in UI to match style
            if(target === 0) styleNameEl.style.color = '#ffcc00';
            if(target === 1) styleNameEl.style.color = '#00ffff';
            if(target === 2) styleNameEl.style.color = '#33ff33';

            gsap.to(particleMaterial.uniforms.uMorph, {
                value: target,
                duration: 2.0,
                ease: "power2.inOut"
            });
        });

        const bloomF = gui.addFolder('ÂÖâÊïàËÆæÁΩÆ');
        bloomF.add(config, 'bloomStrength', 0, 3).onChange(v => bloomPass.strength = v);
        bloomF.add(config, 'bloomRadius', 0, 1).onChange(v => bloomPass.radius = v);

        // ÁÇπÂáªÂ±èÂπïÂàáÊç¢È£éÊ†ºÔºàÁßªÂä®Á´ØÔºâ
        const tapHint = document.getElementById('tap-hint');
        let lastTapTime = 0;
        
        function switchStyle() {
            currentStyleIndex = (currentStyleIndex + 1) % styleNames.length;
            const newStyle = styleNames[currentStyleIndex];
            guiCtrl.style = newStyle;
            styleNameEl.innerText = newStyle;
            
            let target = styleMap[newStyle];
            if(target === 0) styleNameEl.style.color = '#ffcc00';
            if(target === 1) styleNameEl.style.color = '#00ffff';
            if(target === 2) styleNameEl.style.color = '#33ff33';

            gsap.to(particleMaterial.uniforms.uMorph, {
                value: target,
                duration: 2.0,
                ease: "power2.inOut"
            });
            
            // Êõ¥Êñ∞ GUI ÊòæÁ§∫
            gui.updateDisplay();
        }
        
        // ÂèåÂáªÂàáÊç¢È£éÊ†º
        window.addEventListener('dblclick', (e) => {
            if (!isMobile) {
                switchStyle();
            }
        });
        
        // ÁßªÂä®Á´ØÂçïÂáªÂàáÊç¢ÔºàÈÅøÂÖç‰∏éÊªëÂä®ÂÜ≤Á™ÅÔºâ
        let tapStartTime = 0;
        let tapStartPos = { x: 0, y: 0 };
        
        window.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                tapStartTime = Date.now();
                tapStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        });
        
        window.addEventListener('touchend', (e) => {
            if (e.changedTouches.length === 1) {
                const tapDuration = Date.now() - tapStartTime;
                const tapEndPos = { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
                const distance = Math.sqrt(
                    Math.pow(tapEndPos.x - tapStartPos.x, 2) + 
                    Math.pow(tapEndPos.y - tapStartPos.y, 2)
                );
                
                // Â¶ÇÊûúÊòØÂø´ÈÄüÁÇπÂáªÔºà‰∏çÊòØÊªëÂä®Ôºâ
                if (tapDuration < 300 && distance < 20) {
                    const now = Date.now();
                    // Èò≤ÊäñÔºö500ms ÂÜÖÂè™ÂìçÂ∫î‰∏ÄÊ¨°
                    if (now - lastTapTime > 500) {
                        lastTapTime = now;
                        switchStyle();
                        
                        // ÈöêËóèÊèêÁ§∫
                        if (tapHint) {
                            gsap.to(tapHint, { opacity: 0, duration: 0.5, onComplete: () => {
                                tapHint.style.display = 'none';
                            }});
                        }
                    }
                }
            }
        });
        
        // 3ÁßíÂêéÈöêËóèÊèêÁ§∫
        if (isMobile && tapHint) {
            setTimeout(() => {
                gsap.to(tapHint, { opacity: 0, duration: 1, onComplete: () => {
                    tapHint.style.display = 'none';
                }});
            }, 3000);
        } else if (!isMobile && tapHint) {
            tapHint.style.display = 'none';
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            particleMaterial.uniforms.uPixelRatio.value = isMobile ? 1 : Math.min(window.devicePixelRatio, 2);
        });
    </script>
</body>
</html>